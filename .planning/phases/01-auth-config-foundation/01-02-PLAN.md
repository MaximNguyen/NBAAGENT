---
phase: 01-auth-config-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - nba_betting_agent/api/auth.py
  - nba_betting_agent/api/routers/auth.py
  - nba_betting_agent/api/schemas.py
  - nba_betting_agent/api/app.py
  - nba_betting_agent/api/routers/ws.py
autonomous: true

user_setup:
  - service: local-environment
    why: "App requires secrets in environment to start"
    env_vars:
      - name: JWT_SECRET_KEY
        source: "Generate with: openssl rand -hex 32"
      - name: DASHBOARD_PASSWORD_HASH
        source: "Generate with: python -c \"from passlib.context import CryptContext; print(CryptContext(schemes=['bcrypt'], bcrypt__rounds=12).hash(input('Password: ')))\""

must_haves:
  truths:
    - "User can log in with bcrypt-hashed password and receive PyJWT-encoded access token (1hr) and refresh token (7 day)"
    - "User can refresh expired access token using valid refresh token without re-entering password"
    - "Protected endpoints reject requests with expired or invalid tokens"
    - "Access tokens cannot be used at the refresh endpoint and vice versa"
    - "No hardcoded credentials exist in source code"
    - "App validates configuration at startup before accepting requests"
    - "API endpoints reject requests with invalid inputs (strings too long, numbers out of range)"
  artifacts:
    - path: "nba_betting_agent/api/auth.py"
      provides: "PyJWT token creation/verification, passlib password hashing"
      contains: "jwt.encode"
    - path: "nba_betting_agent/api/routers/auth.py"
      provides: "Login and refresh endpoints"
      contains: "/auth/refresh"
    - path: "nba_betting_agent/api/schemas.py"
      provides: "Token response model, Field() constraints on request models"
      contains: "class TokenResponse"
    - path: "nba_betting_agent/api/app.py"
      provides: "Startup config validation"
      contains: "get_settings"
  key_links:
    - from: "nba_betting_agent/api/auth.py"
      to: "nba_betting_agent/api/config.py"
      via: "Settings dependency for JWT secret"
      pattern: "settings\\.jwt_secret_key"
    - from: "nba_betting_agent/api/auth.py"
      to: "PyJWT library"
      via: "jwt.encode/jwt.decode calls"
      pattern: "jwt\\.(encode|decode)"
    - from: "nba_betting_agent/api/auth.py"
      to: "passlib library"
      via: "CryptContext for bcrypt"
      pattern: "pwd_context\\.verify"
    - from: "nba_betting_agent/api/routers/auth.py"
      to: "nba_betting_agent/api/auth.py"
      via: "imports for token creation and password verification"
      pattern: "from.*auth import.*create_access_token"
    - from: "nba_betting_agent/api/app.py"
      to: "nba_betting_agent/api/config.py"
      via: "startup validation call"
      pattern: "get_settings\\(\\)"
    - from: "nba_betting_agent/api/routers/ws.py"
      to: "nba_betting_agent/api/auth.py"
      via: "WebSocket token verification"
      pattern: "verify_ws_token"
---

<objective>
Replace the custom JWT implementation and hardcoded credentials with PyJWT, passlib/bcrypt, and environment-based configuration. Add token refresh endpoint. Add Field() validation constraints to API schemas. Wire startup validation into the FastAPI lifespan.

Purpose: This eliminates all critical security vulnerabilities (AUTH-01 through AUTH-07). Custom HMAC-SHA256 JWT is replaced with PyJWT (algorithm verification, automatic expiration). SHA-256 password hash is replaced with bcrypt (GPU-resistant, salted). Hardcoded password and JWT secret are removed from source code. Refresh token endpoint enables session extension without re-authentication.

Output: Rewritten auth.py, updated routers/auth.py with login+refresh, schemas with Token model and Field constraints, app.py with startup validation, ws.py updated for new auth API
</objective>

<execution_context>
@/Users/maxim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/maxim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auth-config-foundation/01-RESEARCH.md
@.planning/phases/01-auth-config-foundation/01-01-SUMMARY.md
@nba_betting_agent/api/auth.py
@nba_betting_agent/api/routers/auth.py
@nba_betting_agent/api/schemas.py
@nba_betting_agent/api/app.py
@nba_betting_agent/api/routers/ws.py
@nba_betting_agent/api/deps.py
@nba_betting_agent/api/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite auth.py with PyJWT and passlib, add Token schema</name>
  <files>
    nba_betting_agent/api/auth.py
    nba_betting_agent/api/schemas.py
  </files>
  <action>
**Rewrite `nba_betting_agent/api/auth.py` entirely.** Delete all existing code and replace with:

1. Imports:
   - `datetime, timedelta, timezone` from datetime
   - `typing.Annotated`
   - `jwt` (PyJWT) and `jwt.exceptions.InvalidTokenError`
   - `fastapi.Depends, HTTPException, status`
   - `fastapi.security.OAuth2PasswordBearer`
   - `passlib.context.CryptContext`
   - `nba_betting_agent.api.config.Settings, get_settings`

2. Module-level constants:
   - `oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")` — matches the existing URL pattern
   - `pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto", bcrypt__rounds=12)`

3. Functions (follow research patterns EXACTLY):
   - `def create_access_token(username: str, settings: Settings) -> str:` — PyJWT encode with claims: sub=username, exp=now+access_token_expire_minutes, iat=now, type="access". Use `settings.jwt_secret_key` and `settings.jwt_algorithm`.
   - `def create_refresh_token(username: str, settings: Settings) -> str:` — Same as access but exp=now+refresh_token_expire_days, type="refresh".
   - `def verify_password(plain_password: str, hashed_password: str) -> bool:` — `return pwd_context.verify(plain_password, hashed_password)`
   - `def get_password_hash(password: str) -> str:` — `return pwd_context.hash(password)` — utility for generating hashes
   - `async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)], settings: Annotated[Settings, Depends(get_settings)]) -> str:` — Decode JWT with `jwt.decode(token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])`. Extract "sub" and "type" claims. Reject if username is None or type != "access". On any `InvalidTokenError`, raise 401. Return username string.
   - `def verify_ws_token(token: str) -> str | None:` — For WebSocket auth. Call `get_settings()` directly (not via DI since WebSockets don't use standard DI). Try `jwt.decode(...)` with same params. Check type == "access". Return username or None on any error. This maintains backward compatibility with ws.py.

4. CRITICAL: All datetime operations use `datetime.now(timezone.utc)` — NEVER naive datetime.
5. CRITICAL: `algorithms=[settings.jwt_algorithm]` MUST be a list (prevents algorithm confusion attack).
6. CRITICAL: NO hardcoded passwords, secrets, or default fallbacks anywhere in the file.

**Update `nba_betting_agent/api/schemas.py`:**

1. Add `TokenResponse` model:
   ```
   class TokenResponse(BaseModel):
       access_token: str
       refresh_token: str
       token_type: str = "bearer"
   ```

2. Add `RefreshRequest` model:
   ```
   class RefreshRequest(BaseModel):
       refresh_token: str = Field(..., min_length=1, max_length=4096)
   ```

3. Add `LoginRequest` model (replacing the one in routers/auth.py):
   ```
   class LoginRequest(BaseModel):
       username: str = Field(..., min_length=1, max_length=50)
       password: str = Field(..., min_length=1, max_length=72)  # bcrypt truncates at 72 bytes
   ```

4. Add Field() constraints to existing request models that lack them:
   - `AnalysisRunRequest.query`: add `min_length=1, max_length=500`
   - `AnalysisRunRequest.confidence`: add `max_length=20` if provided
   - `AnalysisRunRequest.limit`: add `ge=1, le=100` if provided
   - `AnalysisRunRequest.min_ev`: add `ge=-1.0, le=1.0` if provided

Keep all existing response models unchanged (they don't need input validation).
  </action>
  <verify>
Run with env vars set:
```
JWT_SECRET_KEY=$(openssl rand -hex 32) DASHBOARD_PASSWORD_HASH='$2b$12$placeholder' python -c "
from nba_betting_agent.api.auth import create_access_token, create_refresh_token, verify_password, get_password_hash, get_current_user, verify_ws_token
from nba_betting_agent.api.config import get_settings
s = get_settings()
access = create_access_token('testuser', s)
refresh = create_refresh_token('testuser', s)
print(f'Access token created: {len(access)} chars')
print(f'Refresh token created: {len(refresh)} chars')
import jwt
a_payload = jwt.decode(access, s.jwt_secret_key, algorithms=['HS256'])
r_payload = jwt.decode(refresh, s.jwt_secret_key, algorithms=['HS256'])
assert a_payload['type'] == 'access', 'Access token wrong type'
assert r_payload['type'] == 'refresh', 'Refresh token wrong type'
assert a_payload['sub'] == 'testuser'
print('Token types correct')
# Test password hashing
h = get_password_hash('testpass')
assert verify_password('testpass', h), 'Password verification failed'
assert not verify_password('wrongpass', h), 'Wrong password should fail'
print('Password hashing works')
# Test ws token verification
assert verify_ws_token(access) == 'testuser', 'WS token verify failed'
assert verify_ws_token('invalid.token') is None, 'Invalid token should return None'
print('All auth functions working')
"
```
Also verify schemas: `python -c "from nba_betting_agent.api.schemas import TokenResponse, RefreshRequest, LoginRequest; print('Schemas OK')"`
  </verify>
  <done>
auth.py uses PyJWT for all token operations (AUTH-01), passlib/bcrypt for password hashing (AUTH-02), gets secrets from Settings (AUTH-03). No hardcoded credentials in source (AUTH-07). Access tokens expire in 1hr, refresh tokens in 7 days (AUTH-05). Token type claims distinguish access from refresh. schemas.py has TokenResponse, RefreshRequest, LoginRequest with Field constraints, and existing models have input validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire login/refresh endpoints, startup validation, and update consumers</name>
  <files>
    nba_betting_agent/api/routers/auth.py
    nba_betting_agent/api/app.py
    nba_betting_agent/api/routers/ws.py
  </files>
  <action>
**Rewrite `nba_betting_agent/api/routers/auth.py`:**

Replace entirely with:
1. Imports: `Annotated` from typing, `APIRouter, Depends, HTTPException, status` from fastapi, `OAuth2PasswordRequestForm` from `fastapi.security` (for standard OAuth2 form login), the new auth functions from `nba_betting_agent.api.auth` (create_access_token, create_refresh_token, verify_password), Settings/get_settings from config, TokenResponse/RefreshRequest/LoginRequest from schemas.
2. `router = APIRouter(tags=["auth"])`
3. Login endpoint `@router.post("/auth/login", response_model=TokenResponse)`:
   - Accept `request: LoginRequest` and `settings: Annotated[Settings, Depends(get_settings)]`
   - Verify password: `verify_password(request.password, settings.dashboard_password_hash)`
   - If invalid: raise 401 with "Invalid username or password" and WWW-Authenticate: Bearer header
   - If valid: create access_token and refresh_token for username "dashboard" (single-user system)
   - Return `TokenResponse(access_token=access_token, refresh_token=refresh_token, token_type="bearer")`
4. Refresh endpoint `@router.post("/auth/refresh", response_model=TokenResponse)`:
   - Accept `request: RefreshRequest` and `settings: Annotated[Settings, Depends(get_settings)]`
   - Import `jwt` and `InvalidTokenError`
   - Decode refresh token with `jwt.decode(request.refresh_token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])`
   - Validate: sub is not None AND type == "refresh" — if either fails, raise 401
   - Create new access_token for the username from the refresh token's sub claim
   - Return `TokenResponse(access_token=access_token, refresh_token=request.refresh_token, token_type="bearer")` — same refresh token returned (basic implementation per research, rotation deferred to Phase 4)
   - On `InvalidTokenError`: raise 401 "Invalid refresh token"

**Update `nba_betting_agent/api/app.py`:**

1. Add import: `from nba_betting_agent.api.config import get_settings`
2. In the `lifespan` function, BEFORE `configure_logging`:
   - Add: `settings = get_settings()` — this triggers pydantic-settings validation. If JWT_SECRET_KEY or DASHBOARD_PASSWORD_HASH are missing, app crashes here with clear error.
   - Replace `log_mode = os.getenv("LOG_MODE", "development")` with `log_mode = settings.environment`
3. Remove `import os` if no longer needed (check if os is used elsewhere in the file — it's used for LOG_MODE which we're replacing, check for other uses).
4. The `get_current_user` import from auth.py stays the same (function signature unchanged, just implementation changed).

**Update `nba_betting_agent/api/routers/ws.py`:**

1. The import `from nba_betting_agent.api.auth import verify_ws_token` stays unchanged — the function still exists with same signature (takes token string, returns username or None). No changes needed to ws.py itself.
   - VERIFY this by checking: ws.py calls `verify_ws_token(token)` and checks `if not username:`. The rewritten verify_ws_token returns `str | None` which is the same contract.
   - If the import works and the return type is compatible, do NOT modify ws.py.

**IMPORTANT considerations:**
- The login URL stays as `/auth/login` (mounted at `/api` prefix in app.py, so full path is `/api/auth/login`)
- The `oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")` in auth.py must match this path
- The request body format changes: old endpoint used JSON body `{"username": "...", "password": "..."}`, new endpoint also uses JSON body via LoginRequest (NOT OAuth2PasswordRequestForm, to avoid breaking the React frontend which sends JSON). Keep it as JSON body, not form data.
  </action>
  <verify>
Start the app with env vars and test endpoints:
```bash
# Generate a test password hash
export JWT_SECRET_KEY=$(openssl rand -hex 32)
export DASHBOARD_PASSWORD_HASH=$(python -c "from passlib.context import CryptContext; print(CryptContext(schemes=['bcrypt'], bcrypt__rounds=12).hash('testpass123'))")

# Verify app starts (startup validation works)
timeout 5 python -c "
import asyncio
from nba_betting_agent.api.app import create_app
app = create_app()
print('App created successfully')
" || true

# Test login endpoint
python -c "
from fastapi.testclient import TestClient
import os
os.environ['JWT_SECRET_KEY'] = os.environ.get('JWT_SECRET_KEY', 'a' * 64)
from passlib.context import CryptContext
os.environ['DASHBOARD_PASSWORD_HASH'] = CryptContext(schemes=['bcrypt'], bcrypt__rounds=4).hash('testpass')
from nba_betting_agent.api.app import create_app
app = create_app()
client = TestClient(app)

# Test login
r = client.post('/api/auth/login', json={'username': 'admin', 'password': 'testpass'})
assert r.status_code == 200, f'Login failed: {r.status_code} {r.text}'
tokens = r.json()
assert 'access_token' in tokens
assert 'refresh_token' in tokens
print(f'Login OK: got access + refresh tokens')

# Test refresh
r2 = client.post('/api/auth/refresh', json={'refresh_token': tokens['refresh_token']})
assert r2.status_code == 200, f'Refresh failed: {r2.status_code} {r2.text}'
new_tokens = r2.json()
assert 'access_token' in new_tokens
print(f'Refresh OK: got new access token')

# Test protected endpoint with access token
r3 = client.get('/api/health')
assert r3.status_code == 200
print(f'Health endpoint OK')

# Test invalid login
r4 = client.post('/api/auth/login', json={'username': 'admin', 'password': 'wrongpass'})
assert r4.status_code == 401, f'Should be 401, got {r4.status_code}'
print(f'Invalid login correctly rejected')

print('All endpoint tests passed')
"
```

Also verify no hardcoded credentials: `grep -rn 'Maxim03\|nba-ev-dashboard-secret\|_PASSWORD_HASH.*=.*hashlib\|_SECRET.*=.*os.getenv' nba_betting_agent/api/auth.py` should return NO results.
  </verify>
  <done>
Login endpoint returns access (1hr) + refresh (7day) tokens via PyJWT (AUTH-01, AUTH-05). Password verified with bcrypt (AUTH-02). Refresh endpoint exchanges valid refresh token for new access token (AUTH-06). App crashes at startup if JWT_SECRET_KEY or DASHBOARD_PASSWORD_HASH missing (AUTH-04). No hardcoded credentials in auth.py, routers/auth.py, or any source file (AUTH-07). All secrets loaded from environment via Settings (AUTH-03). WebSocket auth still works via verify_ws_token. Existing protected routes work with new token format.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add auth integration tests</name>
  <files>
    tests/test_auth.py
  </files>
  <action>
Create `tests/test_auth.py` with comprehensive tests for the new auth system. Use FastAPI TestClient and pytest.

**Test setup:**
- Use pytest fixtures to set required env vars (JWT_SECRET_KEY, DASHBOARD_PASSWORD_HASH) before importing app
- Create a `test_settings` fixture that sets env vars and returns Settings instance
- Create a `client` fixture that creates TestClient with the app
- Use bcrypt rounds=4 in tests (faster than production rounds=12, still valid for testing)

**Test cases to implement:**

1. `test_login_valid_credentials` — POST /api/auth/login with correct password returns 200 with access_token, refresh_token, token_type="bearer"
2. `test_login_invalid_password` — POST /api/auth/login with wrong password returns 401
3. `test_login_empty_password` — POST /api/auth/login with empty password returns 422 (Pydantic validation)
4. `test_login_password_too_long` — POST /api/auth/login with >72 char password returns 422
5. `test_access_token_has_correct_claims` — Decode returned access token, verify sub, type="access", exp ~1hr from now
6. `test_refresh_token_has_correct_claims` — Decode returned refresh token, verify sub, type="refresh", exp ~7 days from now
7. `test_refresh_with_valid_refresh_token` — POST /api/auth/refresh with valid refresh token returns new access token
8. `test_refresh_with_access_token_rejected` — POST /api/auth/refresh with an access token (not refresh) returns 401
9. `test_refresh_with_invalid_token_rejected` — POST /api/auth/refresh with garbage token returns 401
10. `test_protected_endpoint_with_valid_token` — GET a protected endpoint with valid access token in Authorization: Bearer header returns 200
11. `test_protected_endpoint_without_token` — GET a protected endpoint without token returns 401/403
12. `test_protected_endpoint_with_expired_token` — Create a token with exp in the past, verify it returns 401
13. `test_no_hardcoded_credentials` — Read auth.py source, assert "Maxim03" not in it, assert "nba-ev-dashboard-secret" not in it
14. `test_settings_crash_without_env_vars` — Clear env vars, verify Settings() raises ValidationError
15. `test_verify_ws_token_valid` — verify_ws_token with valid access token returns username
16. `test_verify_ws_token_invalid` — verify_ws_token with garbage returns None

**Implementation notes:**
- For test 12 (expired token), use PyJWT directly to create a token with past exp, then try to use it
- For test 13, use `pathlib.Path` to read the source file as text
- Import order matters: set env vars in fixtures BEFORE importing app modules that trigger Settings loading. Use `monkeypatch.setenv` in fixtures.
- Use `functools.lru_cache` clearing if needed: `get_settings.cache_clear()` between tests that change env vars
  </action>
  <verify>
Run: `JWT_SECRET_KEY=$(openssl rand -hex 32) DASHBOARD_PASSWORD_HASH=$(python -c "from passlib.context import CryptContext; print(CryptContext(schemes=['bcrypt'], bcrypt__rounds=4).hash('testpass'))") python -m pytest tests/test_auth.py -v`
All tests should pass. Expect 16 tests, 0 failures.
  </verify>
  <done>
16 auth tests pass covering: login success/failure, token claims validation, refresh flow, token type enforcement, protected endpoint access, expired token rejection, hardcoded credential absence, settings fail-fast, and WebSocket token verification. Tests prove AUTH-01 through AUTH-07 requirements are met.
  </done>
</task>

</tasks>

<verification>
**Phase 1 Success Criteria Verification:**

1. "App crashes at startup if JWT_SECRET_KEY or DASHBOARD_PASSWORD_HASH environment variables are missing"
   - Test: `unset JWT_SECRET_KEY && python -c "from nba_betting_agent.api.config import get_settings; get_settings()"` — must crash
   - Covered by: test_settings_crash_without_env_vars

2. "User can log in with bcrypt-hashed password and receive PyJWT-encoded access token (1hr expiry) and refresh token (7 day expiry)"
   - Test: POST /api/auth/login with correct password returns both tokens with correct exp claims
   - Covered by: test_login_valid_credentials, test_access_token_has_correct_claims, test_refresh_token_has_correct_claims

3. "User can refresh expired access token using valid refresh token without re-entering password"
   - Test: POST /api/auth/refresh with refresh token returns new access token
   - Covered by: test_refresh_with_valid_refresh_token, test_refresh_with_access_token_rejected

4. "No credentials (passwords, JWT secrets, API keys) exist in source code or git history"
   - Test: grep source files for known secrets
   - Covered by: test_no_hardcoded_credentials
   - NOTE: Git history cleanup is a separate operational concern (documented in STATE.md blockers)

5. "All API endpoints reject requests with invalid inputs (strings too long, numbers out of range)"
   - Test: POST /api/auth/login with empty or oversized password returns 422
   - Covered by: test_login_empty_password, test_login_password_too_long, Field() constraints on AnalysisRunRequest
</verification>

<success_criteria>
- auth.py uses PyJWT (not custom HMAC) for all token encoding/decoding with algorithms=["HS256"]
- auth.py uses passlib CryptContext with bcrypt (12 rounds) for password verification
- Login endpoint at /api/auth/login returns access_token (1hr) + refresh_token (7 day) + token_type
- Refresh endpoint at /api/auth/refresh accepts refresh_token and returns new access_token
- Access tokens rejected at refresh endpoint, refresh tokens rejected at protected endpoints
- app.py calls get_settings() in lifespan, crashing if env vars missing
- Zero hardcoded credentials in any source file (no passwords, no JWT secrets, no fallback defaults)
- schemas.py has Field() constraints on all request model fields
- 16 auth tests pass
- Existing functionality (protected routes, WebSocket auth, health endpoint) works with new auth
</success_criteria>

<output>
After completion, create `.planning/phases/01-auth-config-foundation/01-02-SUMMARY.md`
</output>
